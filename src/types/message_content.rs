use crate::errors::Result;
use crate::types::*;
use uuid::Uuid;

use std::fmt::Debug;

/// Contains the content of a message
pub trait TDMessageContent: Debug + RObject {}

/// Contains the content of a message
#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(tag = "@type")]
pub enum MessageContent {
    #[doc(hidden)]
    _Default,
    /// A message with an animated emoji
    #[serde(rename = "messageAnimatedEmoji")]
    MessageAnimatedEmoji(MessageAnimatedEmoji),
    /// An animation message (GIF-style).
    #[serde(rename = "messageAnimation")]
    MessageAnimation(MessageAnimation),
    /// An audio message
    #[serde(rename = "messageAudio")]
    MessageAudio(MessageAudio),
    /// A newly created basic group
    #[serde(rename = "messageBasicGroupChatCreate")]
    MessageBasicGroupChatCreate(MessageBasicGroupChatCreate),
    /// A message with information about an ended call
    #[serde(rename = "messageCall")]
    MessageCall(MessageCall),
    /// New chat members were added
    #[serde(rename = "messageChatAddMembers")]
    MessageChatAddMembers(MessageChatAddMembers),
    /// An updated chat photo
    #[serde(rename = "messageChatChangePhoto")]
    MessageChatChangePhoto(MessageChatChangePhoto),
    /// An updated chat title
    #[serde(rename = "messageChatChangeTitle")]
    MessageChatChangeTitle(MessageChatChangeTitle),
    /// A chat member was deleted
    #[serde(rename = "messageChatDeleteMember")]
    MessageChatDeleteMember(MessageChatDeleteMember),
    /// A deleted chat photo
    #[serde(rename = "messageChatDeletePhoto")]
    MessageChatDeletePhoto(MessageChatDeletePhoto),
    /// A new member joined the chat via an invite link
    #[serde(rename = "messageChatJoinByLink")]
    MessageChatJoinByLink(MessageChatJoinByLink),
    /// A new member was accepted to the chat by an administrator
    #[serde(rename = "messageChatJoinByRequest")]
    MessageChatJoinByRequest(MessageChatJoinByRequest),
    /// A theme in the chat has been changed
    #[serde(rename = "messageChatSetTheme")]
    MessageChatSetTheme(MessageChatSetTheme),
    /// The TTL (Time To Live) setting for messages in the chat has been changed
    #[serde(rename = "messageChatSetTtl")]
    MessageChatSetTtl(MessageChatSetTtl),
    /// A supergroup has been created from a basic group
    #[serde(rename = "messageChatUpgradeFrom")]
    MessageChatUpgradeFrom(MessageChatUpgradeFrom),
    /// A basic group was upgraded to a supergroup and was deactivated as the result
    #[serde(rename = "messageChatUpgradeTo")]
    MessageChatUpgradeTo(MessageChatUpgradeTo),
    /// A message with a user contact
    #[serde(rename = "messageContact")]
    MessageContact(MessageContact),
    /// A contact has registered with Telegram
    #[serde(rename = "messageContactRegistered")]
    MessageContactRegistered(MessageContactRegistered),
    /// A non-standard action has happened in the chat
    #[serde(rename = "messageCustomServiceAction")]
    MessageCustomServiceAction(MessageCustomServiceAction),
    /// A dice message. The dice value is randomly generated by the server
    #[serde(rename = "messageDice")]
    MessageDice(Box<MessageDice>),
    /// A document message (general file)
    #[serde(rename = "messageDocument")]
    MessageDocument(MessageDocument),
    /// An expired photo message (self-destructed after TTL has elapsed)
    #[serde(rename = "messageExpiredPhoto")]
    MessageExpiredPhoto(MessageExpiredPhoto),
    /// An expired video message (self-destructed after TTL has elapsed)
    #[serde(rename = "messageExpiredVideo")]
    MessageExpiredVideo(MessageExpiredVideo),
    /// A message with a game
    #[serde(rename = "messageGame")]
    MessageGame(MessageGame),
    /// A new high score was achieved in a game
    #[serde(rename = "messageGameScore")]
    MessageGameScore(MessageGameScore),
    /// A message with information about an invite to a video chat
    #[serde(rename = "messageInviteVideoChatParticipants")]
    MessageInviteVideoChatParticipants(MessageInviteVideoChatParticipants),
    /// A message with an invoice from a bot
    #[serde(rename = "messageInvoice")]
    MessageInvoice(MessageInvoice),
    /// A message with a location
    #[serde(rename = "messageLocation")]
    MessageLocation(MessageLocation),
    /// Telegram Passport data has been received; for bots only
    #[serde(rename = "messagePassportDataReceived")]
    MessagePassportDataReceived(MessagePassportDataReceived),
    /// Telegram Passport data has been sent
    #[serde(rename = "messagePassportDataSent")]
    MessagePassportDataSent(MessagePassportDataSent),
    /// A payment has been completed
    #[serde(rename = "messagePaymentSuccessful")]
    MessagePaymentSuccessful(MessagePaymentSuccessful),
    /// A payment has been completed; for bots only
    #[serde(rename = "messagePaymentSuccessfulBot")]
    MessagePaymentSuccessfulBot(MessagePaymentSuccessfulBot),
    /// A photo message
    #[serde(rename = "messagePhoto")]
    MessagePhoto(MessagePhoto),
    /// A message has been pinned
    #[serde(rename = "messagePinMessage")]
    MessagePinMessage(MessagePinMessage),
    /// A message with a poll
    #[serde(rename = "messagePoll")]
    MessagePoll(MessagePoll),
    /// A user in the chat came within proximity alert range
    #[serde(rename = "messageProximityAlertTriggered")]
    MessageProximityAlertTriggered(MessageProximityAlertTriggered),
    /// A screenshot of a message in the chat has been taken
    #[serde(rename = "messageScreenshotTaken")]
    MessageScreenshotTaken(MessageScreenshotTaken),
    /// A sticker message
    #[serde(rename = "messageSticker")]
    MessageSticker(MessageSticker),
    /// A newly created supergroup or channel
    #[serde(rename = "messageSupergroupChatCreate")]
    MessageSupergroupChatCreate(MessageSupergroupChatCreate),
    /// A text message
    #[serde(rename = "messageText")]
    MessageText(Box<MessageText>),
    /// Message content that is not supported in the current TDLib version
    #[serde(rename = "messageUnsupported")]
    MessageUnsupported(MessageUnsupported),
    /// A message with information about a venue
    #[serde(rename = "messageVenue")]
    MessageVenue(MessageVenue),
    /// A video message
    #[serde(rename = "messageVideo")]
    MessageVideo(MessageVideo),
    /// A message with information about an ended video chat
    #[serde(rename = "messageVideoChatEnded")]
    MessageVideoChatEnded(MessageVideoChatEnded),
    /// A new video chat was scheduled
    #[serde(rename = "messageVideoChatScheduled")]
    MessageVideoChatScheduled(MessageVideoChatScheduled),
    /// A newly created video chat
    #[serde(rename = "messageVideoChatStarted")]
    MessageVideoChatStarted(MessageVideoChatStarted),
    /// A video note message
    #[serde(rename = "messageVideoNote")]
    MessageVideoNote(MessageVideoNote),
    /// A voice note message
    #[serde(rename = "messageVoiceNote")]
    MessageVoiceNote(MessageVoiceNote),
    /// The current user has connected a website by logging in using Telegram Login Widget on it
    #[serde(rename = "messageWebsiteConnected")]
    MessageWebsiteConnected(MessageWebsiteConnected),
}

impl Default for MessageContent {
    fn default() -> Self {
        MessageContent::_Default
    }
}

impl RObject for MessageContent {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        match self {
            MessageContent::MessageAnimatedEmoji(t) => t.extra(),
            MessageContent::MessageAnimation(t) => t.extra(),
            MessageContent::MessageAudio(t) => t.extra(),
            MessageContent::MessageBasicGroupChatCreate(t) => t.extra(),
            MessageContent::MessageCall(t) => t.extra(),
            MessageContent::MessageChatAddMembers(t) => t.extra(),
            MessageContent::MessageChatChangePhoto(t) => t.extra(),
            MessageContent::MessageChatChangeTitle(t) => t.extra(),
            MessageContent::MessageChatDeleteMember(t) => t.extra(),
            MessageContent::MessageChatDeletePhoto(t) => t.extra(),
            MessageContent::MessageChatJoinByLink(t) => t.extra(),
            MessageContent::MessageChatJoinByRequest(t) => t.extra(),
            MessageContent::MessageChatSetTheme(t) => t.extra(),
            MessageContent::MessageChatSetTtl(t) => t.extra(),
            MessageContent::MessageChatUpgradeFrom(t) => t.extra(),
            MessageContent::MessageChatUpgradeTo(t) => t.extra(),
            MessageContent::MessageContact(t) => t.extra(),
            MessageContent::MessageContactRegistered(t) => t.extra(),
            MessageContent::MessageCustomServiceAction(t) => t.extra(),
            MessageContent::MessageDice(t) => t.extra(),
            MessageContent::MessageDocument(t) => t.extra(),
            MessageContent::MessageExpiredPhoto(t) => t.extra(),
            MessageContent::MessageExpiredVideo(t) => t.extra(),
            MessageContent::MessageGame(t) => t.extra(),
            MessageContent::MessageGameScore(t) => t.extra(),
            MessageContent::MessageInviteVideoChatParticipants(t) => t.extra(),
            MessageContent::MessageInvoice(t) => t.extra(),
            MessageContent::MessageLocation(t) => t.extra(),
            MessageContent::MessagePassportDataReceived(t) => t.extra(),
            MessageContent::MessagePassportDataSent(t) => t.extra(),
            MessageContent::MessagePaymentSuccessful(t) => t.extra(),
            MessageContent::MessagePaymentSuccessfulBot(t) => t.extra(),
            MessageContent::MessagePhoto(t) => t.extra(),
            MessageContent::MessagePinMessage(t) => t.extra(),
            MessageContent::MessagePoll(t) => t.extra(),
            MessageContent::MessageProximityAlertTriggered(t) => t.extra(),
            MessageContent::MessageScreenshotTaken(t) => t.extra(),
            MessageContent::MessageSticker(t) => t.extra(),
            MessageContent::MessageSupergroupChatCreate(t) => t.extra(),
            MessageContent::MessageText(t) => t.extra(),
            MessageContent::MessageUnsupported(t) => t.extra(),
            MessageContent::MessageVenue(t) => t.extra(),
            MessageContent::MessageVideo(t) => t.extra(),
            MessageContent::MessageVideoChatEnded(t) => t.extra(),
            MessageContent::MessageVideoChatScheduled(t) => t.extra(),
            MessageContent::MessageVideoChatStarted(t) => t.extra(),
            MessageContent::MessageVideoNote(t) => t.extra(),
            MessageContent::MessageVoiceNote(t) => t.extra(),
            MessageContent::MessageWebsiteConnected(t) => t.extra(),

            _ => None,
        }
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        match self {
            MessageContent::MessageAnimatedEmoji(t) => t.client_id(),
            MessageContent::MessageAnimation(t) => t.client_id(),
            MessageContent::MessageAudio(t) => t.client_id(),
            MessageContent::MessageBasicGroupChatCreate(t) => t.client_id(),
            MessageContent::MessageCall(t) => t.client_id(),
            MessageContent::MessageChatAddMembers(t) => t.client_id(),
            MessageContent::MessageChatChangePhoto(t) => t.client_id(),
            MessageContent::MessageChatChangeTitle(t) => t.client_id(),
            MessageContent::MessageChatDeleteMember(t) => t.client_id(),
            MessageContent::MessageChatDeletePhoto(t) => t.client_id(),
            MessageContent::MessageChatJoinByLink(t) => t.client_id(),
            MessageContent::MessageChatJoinByRequest(t) => t.client_id(),
            MessageContent::MessageChatSetTheme(t) => t.client_id(),
            MessageContent::MessageChatSetTtl(t) => t.client_id(),
            MessageContent::MessageChatUpgradeFrom(t) => t.client_id(),
            MessageContent::MessageChatUpgradeTo(t) => t.client_id(),
            MessageContent::MessageContact(t) => t.client_id(),
            MessageContent::MessageContactRegistered(t) => t.client_id(),
            MessageContent::MessageCustomServiceAction(t) => t.client_id(),
            MessageContent::MessageDice(t) => t.client_id(),
            MessageContent::MessageDocument(t) => t.client_id(),
            MessageContent::MessageExpiredPhoto(t) => t.client_id(),
            MessageContent::MessageExpiredVideo(t) => t.client_id(),
            MessageContent::MessageGame(t) => t.client_id(),
            MessageContent::MessageGameScore(t) => t.client_id(),
            MessageContent::MessageInviteVideoChatParticipants(t) => t.client_id(),
            MessageContent::MessageInvoice(t) => t.client_id(),
            MessageContent::MessageLocation(t) => t.client_id(),
            MessageContent::MessagePassportDataReceived(t) => t.client_id(),
            MessageContent::MessagePassportDataSent(t) => t.client_id(),
            MessageContent::MessagePaymentSuccessful(t) => t.client_id(),
            MessageContent::MessagePaymentSuccessfulBot(t) => t.client_id(),
            MessageContent::MessagePhoto(t) => t.client_id(),
            MessageContent::MessagePinMessage(t) => t.client_id(),
            MessageContent::MessagePoll(t) => t.client_id(),
            MessageContent::MessageProximityAlertTriggered(t) => t.client_id(),
            MessageContent::MessageScreenshotTaken(t) => t.client_id(),
            MessageContent::MessageSticker(t) => t.client_id(),
            MessageContent::MessageSupergroupChatCreate(t) => t.client_id(),
            MessageContent::MessageText(t) => t.client_id(),
            MessageContent::MessageUnsupported(t) => t.client_id(),
            MessageContent::MessageVenue(t) => t.client_id(),
            MessageContent::MessageVideo(t) => t.client_id(),
            MessageContent::MessageVideoChatEnded(t) => t.client_id(),
            MessageContent::MessageVideoChatScheduled(t) => t.client_id(),
            MessageContent::MessageVideoChatStarted(t) => t.client_id(),
            MessageContent::MessageVideoNote(t) => t.client_id(),
            MessageContent::MessageVoiceNote(t) => t.client_id(),
            MessageContent::MessageWebsiteConnected(t) => t.client_id(),

            _ => None,
        }
    }
}

impl MessageContent {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    #[doc(hidden)]
    pub fn _is_default(&self) -> bool {
        matches!(self, MessageContent::_Default)
    }
}

impl AsRef<MessageContent> for MessageContent {
    fn as_ref(&self) -> &MessageContent {
        self
    }
}

/// A message with an animated emoji
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageAnimatedEmoji {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The animated emoji
    animated_emoji: AnimatedEmoji,
    /// The corresponding emoji

    #[serde(default)]
    emoji: String,
}

impl RObject for MessageAnimatedEmoji {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageAnimatedEmoji {}

impl MessageAnimatedEmoji {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageAnimatedEmojiBuilder {
        let mut inner = MessageAnimatedEmoji::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageAnimatedEmojiBuilder { inner }
    }

    pub fn animated_emoji(&self) -> &AnimatedEmoji {
        &self.animated_emoji
    }

    pub fn emoji(&self) -> &String {
        &self.emoji
    }
}

#[doc(hidden)]
pub struct MessageAnimatedEmojiBuilder {
    inner: MessageAnimatedEmoji,
}

#[deprecated]
pub type RTDMessageAnimatedEmojiBuilder = MessageAnimatedEmojiBuilder;

impl MessageAnimatedEmojiBuilder {
    pub fn build(&self) -> MessageAnimatedEmoji {
        self.inner.clone()
    }

    pub fn animated_emoji<T: AsRef<AnimatedEmoji>>(&mut self, animated_emoji: T) -> &mut Self {
        self.inner.animated_emoji = animated_emoji.as_ref().clone();
        self
    }

    pub fn emoji<T: AsRef<str>>(&mut self, emoji: T) -> &mut Self {
        self.inner.emoji = emoji.as_ref().to_string();
        self
    }
}

impl AsRef<MessageAnimatedEmoji> for MessageAnimatedEmoji {
    fn as_ref(&self) -> &MessageAnimatedEmoji {
        self
    }
}

impl AsRef<MessageAnimatedEmoji> for MessageAnimatedEmojiBuilder {
    fn as_ref(&self) -> &MessageAnimatedEmoji {
        &self.inner
    }
}

/// An animation message (GIF-style).
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageAnimation {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The animation description
    animation: Animation,
    /// Animation caption
    caption: FormattedText,
    /// True, if the animation thumbnail must be blurred and the animation must be shown only while tapped

    #[serde(default)]
    is_secret: bool,
}

impl RObject for MessageAnimation {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageAnimation {}

impl MessageAnimation {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageAnimationBuilder {
        let mut inner = MessageAnimation::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageAnimationBuilder { inner }
    }

    pub fn animation(&self) -> &Animation {
        &self.animation
    }

    pub fn caption(&self) -> &FormattedText {
        &self.caption
    }

    pub fn is_secret(&self) -> bool {
        self.is_secret
    }
}

#[doc(hidden)]
pub struct MessageAnimationBuilder {
    inner: MessageAnimation,
}

#[deprecated]
pub type RTDMessageAnimationBuilder = MessageAnimationBuilder;

impl MessageAnimationBuilder {
    pub fn build(&self) -> MessageAnimation {
        self.inner.clone()
    }

    pub fn animation<T: AsRef<Animation>>(&mut self, animation: T) -> &mut Self {
        self.inner.animation = animation.as_ref().clone();
        self
    }

    pub fn caption<T: AsRef<FormattedText>>(&mut self, caption: T) -> &mut Self {
        self.inner.caption = caption.as_ref().clone();
        self
    }

    pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
        self.inner.is_secret = is_secret;
        self
    }
}

impl AsRef<MessageAnimation> for MessageAnimation {
    fn as_ref(&self) -> &MessageAnimation {
        self
    }
}

impl AsRef<MessageAnimation> for MessageAnimationBuilder {
    fn as_ref(&self) -> &MessageAnimation {
        &self.inner
    }
}

/// An audio message
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageAudio {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The audio description
    audio: Audio,
    /// Audio caption
    caption: FormattedText,
}

impl RObject for MessageAudio {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageAudio {}

impl MessageAudio {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageAudioBuilder {
        let mut inner = MessageAudio::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageAudioBuilder { inner }
    }

    pub fn audio(&self) -> &Audio {
        &self.audio
    }

    pub fn caption(&self) -> &FormattedText {
        &self.caption
    }
}

#[doc(hidden)]
pub struct MessageAudioBuilder {
    inner: MessageAudio,
}

#[deprecated]
pub type RTDMessageAudioBuilder = MessageAudioBuilder;

impl MessageAudioBuilder {
    pub fn build(&self) -> MessageAudio {
        self.inner.clone()
    }

    pub fn audio<T: AsRef<Audio>>(&mut self, audio: T) -> &mut Self {
        self.inner.audio = audio.as_ref().clone();
        self
    }

    pub fn caption<T: AsRef<FormattedText>>(&mut self, caption: T) -> &mut Self {
        self.inner.caption = caption.as_ref().clone();
        self
    }
}

impl AsRef<MessageAudio> for MessageAudio {
    fn as_ref(&self) -> &MessageAudio {
        self
    }
}

impl AsRef<MessageAudio> for MessageAudioBuilder {
    fn as_ref(&self) -> &MessageAudio {
        &self.inner
    }
}

/// A newly created basic group
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageBasicGroupChatCreate {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Title of the basic group

    #[serde(default)]
    title: String,
    /// User identifiers of members in the basic group

    #[serde(default)]
    member_user_ids: Vec<i64>,
}

impl RObject for MessageBasicGroupChatCreate {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageBasicGroupChatCreate {}

impl MessageBasicGroupChatCreate {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageBasicGroupChatCreateBuilder {
        let mut inner = MessageBasicGroupChatCreate::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageBasicGroupChatCreateBuilder { inner }
    }

    pub fn title(&self) -> &String {
        &self.title
    }

    pub fn member_user_ids(&self) -> &Vec<i64> {
        &self.member_user_ids
    }
}

#[doc(hidden)]
pub struct MessageBasicGroupChatCreateBuilder {
    inner: MessageBasicGroupChatCreate,
}

#[deprecated]
pub type RTDMessageBasicGroupChatCreateBuilder = MessageBasicGroupChatCreateBuilder;

impl MessageBasicGroupChatCreateBuilder {
    pub fn build(&self) -> MessageBasicGroupChatCreate {
        self.inner.clone()
    }

    pub fn title<T: AsRef<str>>(&mut self, title: T) -> &mut Self {
        self.inner.title = title.as_ref().to_string();
        self
    }

    pub fn member_user_ids(&mut self, member_user_ids: Vec<i64>) -> &mut Self {
        self.inner.member_user_ids = member_user_ids;
        self
    }
}

impl AsRef<MessageBasicGroupChatCreate> for MessageBasicGroupChatCreate {
    fn as_ref(&self) -> &MessageBasicGroupChatCreate {
        self
    }
}

impl AsRef<MessageBasicGroupChatCreate> for MessageBasicGroupChatCreateBuilder {
    fn as_ref(&self) -> &MessageBasicGroupChatCreate {
        &self.inner
    }
}

/// A message with information about an ended call
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageCall {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// True, if the call was a video call

    #[serde(default)]
    is_video: bool,
    /// Reason why the call was discarded

    #[serde(skip_serializing_if = "CallDiscardReason::_is_default")]
    discard_reason: CallDiscardReason,
    /// Call duration, in seconds

    #[serde(default)]
    duration: i32,
}

impl RObject for MessageCall {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageCall {}

impl MessageCall {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageCallBuilder {
        let mut inner = MessageCall::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageCallBuilder { inner }
    }

    pub fn is_video(&self) -> bool {
        self.is_video
    }

    pub fn discard_reason(&self) -> &CallDiscardReason {
        &self.discard_reason
    }

    pub fn duration(&self) -> i32 {
        self.duration
    }
}

#[doc(hidden)]
pub struct MessageCallBuilder {
    inner: MessageCall,
}

#[deprecated]
pub type RTDMessageCallBuilder = MessageCallBuilder;

impl MessageCallBuilder {
    pub fn build(&self) -> MessageCall {
        self.inner.clone()
    }

    pub fn is_video(&mut self, is_video: bool) -> &mut Self {
        self.inner.is_video = is_video;
        self
    }

    pub fn discard_reason<T: AsRef<CallDiscardReason>>(&mut self, discard_reason: T) -> &mut Self {
        self.inner.discard_reason = discard_reason.as_ref().clone();
        self
    }

    pub fn duration(&mut self, duration: i32) -> &mut Self {
        self.inner.duration = duration;
        self
    }
}

impl AsRef<MessageCall> for MessageCall {
    fn as_ref(&self) -> &MessageCall {
        self
    }
}

impl AsRef<MessageCall> for MessageCallBuilder {
    fn as_ref(&self) -> &MessageCall {
        &self.inner
    }
}

/// New chat members were added
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageChatAddMembers {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// User identifiers of the new members

    #[serde(default)]
    member_user_ids: Vec<i64>,
}

impl RObject for MessageChatAddMembers {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageChatAddMembers {}

impl MessageChatAddMembers {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageChatAddMembersBuilder {
        let mut inner = MessageChatAddMembers::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageChatAddMembersBuilder { inner }
    }

    pub fn member_user_ids(&self) -> &Vec<i64> {
        &self.member_user_ids
    }
}

#[doc(hidden)]
pub struct MessageChatAddMembersBuilder {
    inner: MessageChatAddMembers,
}

#[deprecated]
pub type RTDMessageChatAddMembersBuilder = MessageChatAddMembersBuilder;

impl MessageChatAddMembersBuilder {
    pub fn build(&self) -> MessageChatAddMembers {
        self.inner.clone()
    }

    pub fn member_user_ids(&mut self, member_user_ids: Vec<i64>) -> &mut Self {
        self.inner.member_user_ids = member_user_ids;
        self
    }
}

impl AsRef<MessageChatAddMembers> for MessageChatAddMembers {
    fn as_ref(&self) -> &MessageChatAddMembers {
        self
    }
}

impl AsRef<MessageChatAddMembers> for MessageChatAddMembersBuilder {
    fn as_ref(&self) -> &MessageChatAddMembers {
        &self.inner
    }
}

/// An updated chat photo
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageChatChangePhoto {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// New chat photo
    photo: ChatPhoto,
}

impl RObject for MessageChatChangePhoto {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageChatChangePhoto {}

impl MessageChatChangePhoto {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageChatChangePhotoBuilder {
        let mut inner = MessageChatChangePhoto::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageChatChangePhotoBuilder { inner }
    }

    pub fn photo(&self) -> &ChatPhoto {
        &self.photo
    }
}

#[doc(hidden)]
pub struct MessageChatChangePhotoBuilder {
    inner: MessageChatChangePhoto,
}

#[deprecated]
pub type RTDMessageChatChangePhotoBuilder = MessageChatChangePhotoBuilder;

impl MessageChatChangePhotoBuilder {
    pub fn build(&self) -> MessageChatChangePhoto {
        self.inner.clone()
    }

    pub fn photo<T: AsRef<ChatPhoto>>(&mut self, photo: T) -> &mut Self {
        self.inner.photo = photo.as_ref().clone();
        self
    }
}

impl AsRef<MessageChatChangePhoto> for MessageChatChangePhoto {
    fn as_ref(&self) -> &MessageChatChangePhoto {
        self
    }
}

impl AsRef<MessageChatChangePhoto> for MessageChatChangePhotoBuilder {
    fn as_ref(&self) -> &MessageChatChangePhoto {
        &self.inner
    }
}

/// An updated chat title
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageChatChangeTitle {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// New chat title

    #[serde(default)]
    title: String,
}

impl RObject for MessageChatChangeTitle {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageChatChangeTitle {}

impl MessageChatChangeTitle {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageChatChangeTitleBuilder {
        let mut inner = MessageChatChangeTitle::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageChatChangeTitleBuilder { inner }
    }

    pub fn title(&self) -> &String {
        &self.title
    }
}

#[doc(hidden)]
pub struct MessageChatChangeTitleBuilder {
    inner: MessageChatChangeTitle,
}

#[deprecated]
pub type RTDMessageChatChangeTitleBuilder = MessageChatChangeTitleBuilder;

impl MessageChatChangeTitleBuilder {
    pub fn build(&self) -> MessageChatChangeTitle {
        self.inner.clone()
    }

    pub fn title<T: AsRef<str>>(&mut self, title: T) -> &mut Self {
        self.inner.title = title.as_ref().to_string();
        self
    }
}

impl AsRef<MessageChatChangeTitle> for MessageChatChangeTitle {
    fn as_ref(&self) -> &MessageChatChangeTitle {
        self
    }
}

impl AsRef<MessageChatChangeTitle> for MessageChatChangeTitleBuilder {
    fn as_ref(&self) -> &MessageChatChangeTitle {
        &self.inner
    }
}

/// A chat member was deleted
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageChatDeleteMember {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// User identifier of the deleted chat member

    #[serde(default)]
    user_id: i64,
}

impl RObject for MessageChatDeleteMember {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageChatDeleteMember {}

impl MessageChatDeleteMember {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageChatDeleteMemberBuilder {
        let mut inner = MessageChatDeleteMember::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageChatDeleteMemberBuilder { inner }
    }

    pub fn user_id(&self) -> i64 {
        self.user_id
    }
}

#[doc(hidden)]
pub struct MessageChatDeleteMemberBuilder {
    inner: MessageChatDeleteMember,
}

#[deprecated]
pub type RTDMessageChatDeleteMemberBuilder = MessageChatDeleteMemberBuilder;

impl MessageChatDeleteMemberBuilder {
    pub fn build(&self) -> MessageChatDeleteMember {
        self.inner.clone()
    }

    pub fn user_id(&mut self, user_id: i64) -> &mut Self {
        self.inner.user_id = user_id;
        self
    }
}

impl AsRef<MessageChatDeleteMember> for MessageChatDeleteMember {
    fn as_ref(&self) -> &MessageChatDeleteMember {
        self
    }
}

impl AsRef<MessageChatDeleteMember> for MessageChatDeleteMemberBuilder {
    fn as_ref(&self) -> &MessageChatDeleteMember {
        &self.inner
    }
}

/// A deleted chat photo
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageChatDeletePhoto {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
}

impl RObject for MessageChatDeletePhoto {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageChatDeletePhoto {}

impl MessageChatDeletePhoto {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageChatDeletePhotoBuilder {
        let mut inner = MessageChatDeletePhoto::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageChatDeletePhotoBuilder { inner }
    }
}

#[doc(hidden)]
pub struct MessageChatDeletePhotoBuilder {
    inner: MessageChatDeletePhoto,
}

#[deprecated]
pub type RTDMessageChatDeletePhotoBuilder = MessageChatDeletePhotoBuilder;

impl MessageChatDeletePhotoBuilder {
    pub fn build(&self) -> MessageChatDeletePhoto {
        self.inner.clone()
    }
}

impl AsRef<MessageChatDeletePhoto> for MessageChatDeletePhoto {
    fn as_ref(&self) -> &MessageChatDeletePhoto {
        self
    }
}

impl AsRef<MessageChatDeletePhoto> for MessageChatDeletePhotoBuilder {
    fn as_ref(&self) -> &MessageChatDeletePhoto {
        &self.inner
    }
}

/// A new member joined the chat via an invite link
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageChatJoinByLink {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
}

impl RObject for MessageChatJoinByLink {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageChatJoinByLink {}

impl MessageChatJoinByLink {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageChatJoinByLinkBuilder {
        let mut inner = MessageChatJoinByLink::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageChatJoinByLinkBuilder { inner }
    }
}

#[doc(hidden)]
pub struct MessageChatJoinByLinkBuilder {
    inner: MessageChatJoinByLink,
}

#[deprecated]
pub type RTDMessageChatJoinByLinkBuilder = MessageChatJoinByLinkBuilder;

impl MessageChatJoinByLinkBuilder {
    pub fn build(&self) -> MessageChatJoinByLink {
        self.inner.clone()
    }
}

impl AsRef<MessageChatJoinByLink> for MessageChatJoinByLink {
    fn as_ref(&self) -> &MessageChatJoinByLink {
        self
    }
}

impl AsRef<MessageChatJoinByLink> for MessageChatJoinByLinkBuilder {
    fn as_ref(&self) -> &MessageChatJoinByLink {
        &self.inner
    }
}

/// A new member was accepted to the chat by an administrator
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageChatJoinByRequest {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
}

impl RObject for MessageChatJoinByRequest {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageChatJoinByRequest {}

impl MessageChatJoinByRequest {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageChatJoinByRequestBuilder {
        let mut inner = MessageChatJoinByRequest::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageChatJoinByRequestBuilder { inner }
    }
}

#[doc(hidden)]
pub struct MessageChatJoinByRequestBuilder {
    inner: MessageChatJoinByRequest,
}

#[deprecated]
pub type RTDMessageChatJoinByRequestBuilder = MessageChatJoinByRequestBuilder;

impl MessageChatJoinByRequestBuilder {
    pub fn build(&self) -> MessageChatJoinByRequest {
        self.inner.clone()
    }
}

impl AsRef<MessageChatJoinByRequest> for MessageChatJoinByRequest {
    fn as_ref(&self) -> &MessageChatJoinByRequest {
        self
    }
}

impl AsRef<MessageChatJoinByRequest> for MessageChatJoinByRequestBuilder {
    fn as_ref(&self) -> &MessageChatJoinByRequest {
        &self.inner
    }
}

/// A theme in the chat has been changed
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageChatSetTheme {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// If non-empty, name of a new theme, set for the chat. Otherwise chat theme was reset to the default one

    #[serde(default)]
    theme_name: String,
}

impl RObject for MessageChatSetTheme {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageChatSetTheme {}

impl MessageChatSetTheme {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageChatSetThemeBuilder {
        let mut inner = MessageChatSetTheme::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageChatSetThemeBuilder { inner }
    }

    pub fn theme_name(&self) -> &String {
        &self.theme_name
    }
}

#[doc(hidden)]
pub struct MessageChatSetThemeBuilder {
    inner: MessageChatSetTheme,
}

#[deprecated]
pub type RTDMessageChatSetThemeBuilder = MessageChatSetThemeBuilder;

impl MessageChatSetThemeBuilder {
    pub fn build(&self) -> MessageChatSetTheme {
        self.inner.clone()
    }

    pub fn theme_name<T: AsRef<str>>(&mut self, theme_name: T) -> &mut Self {
        self.inner.theme_name = theme_name.as_ref().to_string();
        self
    }
}

impl AsRef<MessageChatSetTheme> for MessageChatSetTheme {
    fn as_ref(&self) -> &MessageChatSetTheme {
        self
    }
}

impl AsRef<MessageChatSetTheme> for MessageChatSetThemeBuilder {
    fn as_ref(&self) -> &MessageChatSetTheme {
        &self.inner
    }
}

/// The TTL (Time To Live) setting for messages in the chat has been changed
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageChatSetTtl {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// New message TTL

    #[serde(default)]
    ttl: i32,
}

impl RObject for MessageChatSetTtl {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageChatSetTtl {}

impl MessageChatSetTtl {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageChatSetTtlBuilder {
        let mut inner = MessageChatSetTtl::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageChatSetTtlBuilder { inner }
    }

    pub fn ttl(&self) -> i32 {
        self.ttl
    }
}

#[doc(hidden)]
pub struct MessageChatSetTtlBuilder {
    inner: MessageChatSetTtl,
}

#[deprecated]
pub type RTDMessageChatSetTtlBuilder = MessageChatSetTtlBuilder;

impl MessageChatSetTtlBuilder {
    pub fn build(&self) -> MessageChatSetTtl {
        self.inner.clone()
    }

    pub fn ttl(&mut self, ttl: i32) -> &mut Self {
        self.inner.ttl = ttl;
        self
    }
}

impl AsRef<MessageChatSetTtl> for MessageChatSetTtl {
    fn as_ref(&self) -> &MessageChatSetTtl {
        self
    }
}

impl AsRef<MessageChatSetTtl> for MessageChatSetTtlBuilder {
    fn as_ref(&self) -> &MessageChatSetTtl {
        &self.inner
    }
}

/// A supergroup has been created from a basic group
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageChatUpgradeFrom {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Title of the newly created supergroup

    #[serde(default)]
    title: String,
    /// The identifier of the original basic group

    #[serde(default)]
    basic_group_id: i64,
}

impl RObject for MessageChatUpgradeFrom {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageChatUpgradeFrom {}

impl MessageChatUpgradeFrom {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageChatUpgradeFromBuilder {
        let mut inner = MessageChatUpgradeFrom::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageChatUpgradeFromBuilder { inner }
    }

    pub fn title(&self) -> &String {
        &self.title
    }

    pub fn basic_group_id(&self) -> i64 {
        self.basic_group_id
    }
}

#[doc(hidden)]
pub struct MessageChatUpgradeFromBuilder {
    inner: MessageChatUpgradeFrom,
}

#[deprecated]
pub type RTDMessageChatUpgradeFromBuilder = MessageChatUpgradeFromBuilder;

impl MessageChatUpgradeFromBuilder {
    pub fn build(&self) -> MessageChatUpgradeFrom {
        self.inner.clone()
    }

    pub fn title<T: AsRef<str>>(&mut self, title: T) -> &mut Self {
        self.inner.title = title.as_ref().to_string();
        self
    }

    pub fn basic_group_id(&mut self, basic_group_id: i64) -> &mut Self {
        self.inner.basic_group_id = basic_group_id;
        self
    }
}

impl AsRef<MessageChatUpgradeFrom> for MessageChatUpgradeFrom {
    fn as_ref(&self) -> &MessageChatUpgradeFrom {
        self
    }
}

impl AsRef<MessageChatUpgradeFrom> for MessageChatUpgradeFromBuilder {
    fn as_ref(&self) -> &MessageChatUpgradeFrom {
        &self.inner
    }
}

/// A basic group was upgraded to a supergroup and was deactivated as the result
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageChatUpgradeTo {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Identifier of the supergroup to which the basic group was upgraded

    #[serde(default)]
    supergroup_id: i64,
}

impl RObject for MessageChatUpgradeTo {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageChatUpgradeTo {}

impl MessageChatUpgradeTo {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageChatUpgradeToBuilder {
        let mut inner = MessageChatUpgradeTo::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageChatUpgradeToBuilder { inner }
    }

    pub fn supergroup_id(&self) -> i64 {
        self.supergroup_id
    }
}

#[doc(hidden)]
pub struct MessageChatUpgradeToBuilder {
    inner: MessageChatUpgradeTo,
}

#[deprecated]
pub type RTDMessageChatUpgradeToBuilder = MessageChatUpgradeToBuilder;

impl MessageChatUpgradeToBuilder {
    pub fn build(&self) -> MessageChatUpgradeTo {
        self.inner.clone()
    }

    pub fn supergroup_id(&mut self, supergroup_id: i64) -> &mut Self {
        self.inner.supergroup_id = supergroup_id;
        self
    }
}

impl AsRef<MessageChatUpgradeTo> for MessageChatUpgradeTo {
    fn as_ref(&self) -> &MessageChatUpgradeTo {
        self
    }
}

impl AsRef<MessageChatUpgradeTo> for MessageChatUpgradeToBuilder {
    fn as_ref(&self) -> &MessageChatUpgradeTo {
        &self.inner
    }
}

/// A message with a user contact
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageContact {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The contact description
    contact: Contact,
}

impl RObject for MessageContact {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageContact {}

impl MessageContact {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageContactBuilder {
        let mut inner = MessageContact::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageContactBuilder { inner }
    }

    pub fn contact(&self) -> &Contact {
        &self.contact
    }
}

#[doc(hidden)]
pub struct MessageContactBuilder {
    inner: MessageContact,
}

#[deprecated]
pub type RTDMessageContactBuilder = MessageContactBuilder;

impl MessageContactBuilder {
    pub fn build(&self) -> MessageContact {
        self.inner.clone()
    }

    pub fn contact<T: AsRef<Contact>>(&mut self, contact: T) -> &mut Self {
        self.inner.contact = contact.as_ref().clone();
        self
    }
}

impl AsRef<MessageContact> for MessageContact {
    fn as_ref(&self) -> &MessageContact {
        self
    }
}

impl AsRef<MessageContact> for MessageContactBuilder {
    fn as_ref(&self) -> &MessageContact {
        &self.inner
    }
}

/// A contact has registered with Telegram
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageContactRegistered {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
}

impl RObject for MessageContactRegistered {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageContactRegistered {}

impl MessageContactRegistered {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageContactRegisteredBuilder {
        let mut inner = MessageContactRegistered::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageContactRegisteredBuilder { inner }
    }
}

#[doc(hidden)]
pub struct MessageContactRegisteredBuilder {
    inner: MessageContactRegistered,
}

#[deprecated]
pub type RTDMessageContactRegisteredBuilder = MessageContactRegisteredBuilder;

impl MessageContactRegisteredBuilder {
    pub fn build(&self) -> MessageContactRegistered {
        self.inner.clone()
    }
}

impl AsRef<MessageContactRegistered> for MessageContactRegistered {
    fn as_ref(&self) -> &MessageContactRegistered {
        self
    }
}

impl AsRef<MessageContactRegistered> for MessageContactRegisteredBuilder {
    fn as_ref(&self) -> &MessageContactRegistered {
        &self.inner
    }
}

/// A non-standard action has happened in the chat
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageCustomServiceAction {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Message text to be shown in the chat

    #[serde(default)]
    text: String,
}

impl RObject for MessageCustomServiceAction {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageCustomServiceAction {}

impl MessageCustomServiceAction {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageCustomServiceActionBuilder {
        let mut inner = MessageCustomServiceAction::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageCustomServiceActionBuilder { inner }
    }

    pub fn text(&self) -> &String {
        &self.text
    }
}

#[doc(hidden)]
pub struct MessageCustomServiceActionBuilder {
    inner: MessageCustomServiceAction,
}

#[deprecated]
pub type RTDMessageCustomServiceActionBuilder = MessageCustomServiceActionBuilder;

impl MessageCustomServiceActionBuilder {
    pub fn build(&self) -> MessageCustomServiceAction {
        self.inner.clone()
    }

    pub fn text<T: AsRef<str>>(&mut self, text: T) -> &mut Self {
        self.inner.text = text.as_ref().to_string();
        self
    }
}

impl AsRef<MessageCustomServiceAction> for MessageCustomServiceAction {
    fn as_ref(&self) -> &MessageCustomServiceAction {
        self
    }
}

impl AsRef<MessageCustomServiceAction> for MessageCustomServiceActionBuilder {
    fn as_ref(&self) -> &MessageCustomServiceAction {
        &self.inner
    }
}

/// A dice message. The dice value is randomly generated by the server
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageDice {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The animated stickers with the initial dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
    initial_state: Option<DiceStickers>,
    /// The animated stickers with the final dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
    final_state: Option<DiceStickers>,
    /// Emoji on which the dice throw animation is based

    #[serde(default)]
    emoji: String,
    /// The dice value. If the value is 0, the dice don't have final state yet

    #[serde(default)]
    value: i32,
    /// Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded

    #[serde(default)]
    success_animation_frame_number: i32,
}

impl RObject for MessageDice {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageDice {}

impl MessageDice {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageDiceBuilder {
        let mut inner = MessageDice::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageDiceBuilder { inner }
    }

    pub fn initial_state(&self) -> &Option<DiceStickers> {
        &self.initial_state
    }

    pub fn final_state(&self) -> &Option<DiceStickers> {
        &self.final_state
    }

    pub fn emoji(&self) -> &String {
        &self.emoji
    }

    pub fn value(&self) -> i32 {
        self.value
    }

    pub fn success_animation_frame_number(&self) -> i32 {
        self.success_animation_frame_number
    }
}

#[doc(hidden)]
pub struct MessageDiceBuilder {
    inner: MessageDice,
}

#[deprecated]
pub type RTDMessageDiceBuilder = MessageDiceBuilder;

impl MessageDiceBuilder {
    pub fn build(&self) -> MessageDice {
        self.inner.clone()
    }

    pub fn initial_state<T: AsRef<DiceStickers>>(&mut self, initial_state: T) -> &mut Self {
        self.inner.initial_state = Some(initial_state.as_ref().clone());
        self
    }

    pub fn final_state<T: AsRef<DiceStickers>>(&mut self, final_state: T) -> &mut Self {
        self.inner.final_state = Some(final_state.as_ref().clone());
        self
    }

    pub fn emoji<T: AsRef<str>>(&mut self, emoji: T) -> &mut Self {
        self.inner.emoji = emoji.as_ref().to_string();
        self
    }

    pub fn value(&mut self, value: i32) -> &mut Self {
        self.inner.value = value;
        self
    }

    pub fn success_animation_frame_number(
        &mut self,
        success_animation_frame_number: i32,
    ) -> &mut Self {
        self.inner.success_animation_frame_number = success_animation_frame_number;
        self
    }
}

impl AsRef<MessageDice> for MessageDice {
    fn as_ref(&self) -> &MessageDice {
        self
    }
}

impl AsRef<MessageDice> for MessageDiceBuilder {
    fn as_ref(&self) -> &MessageDice {
        &self.inner
    }
}

/// A document message (general file)
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageDocument {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The document description
    document: Document,
    /// Document caption
    caption: FormattedText,
}

impl RObject for MessageDocument {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageDocument {}

impl MessageDocument {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageDocumentBuilder {
        let mut inner = MessageDocument::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageDocumentBuilder { inner }
    }

    pub fn document(&self) -> &Document {
        &self.document
    }

    pub fn caption(&self) -> &FormattedText {
        &self.caption
    }
}

#[doc(hidden)]
pub struct MessageDocumentBuilder {
    inner: MessageDocument,
}

#[deprecated]
pub type RTDMessageDocumentBuilder = MessageDocumentBuilder;

impl MessageDocumentBuilder {
    pub fn build(&self) -> MessageDocument {
        self.inner.clone()
    }

    pub fn document<T: AsRef<Document>>(&mut self, document: T) -> &mut Self {
        self.inner.document = document.as_ref().clone();
        self
    }

    pub fn caption<T: AsRef<FormattedText>>(&mut self, caption: T) -> &mut Self {
        self.inner.caption = caption.as_ref().clone();
        self
    }
}

impl AsRef<MessageDocument> for MessageDocument {
    fn as_ref(&self) -> &MessageDocument {
        self
    }
}

impl AsRef<MessageDocument> for MessageDocumentBuilder {
    fn as_ref(&self) -> &MessageDocument {
        &self.inner
    }
}

/// An expired photo message (self-destructed after TTL has elapsed)
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageExpiredPhoto {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
}

impl RObject for MessageExpiredPhoto {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageExpiredPhoto {}

impl MessageExpiredPhoto {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageExpiredPhotoBuilder {
        let mut inner = MessageExpiredPhoto::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageExpiredPhotoBuilder { inner }
    }
}

#[doc(hidden)]
pub struct MessageExpiredPhotoBuilder {
    inner: MessageExpiredPhoto,
}

#[deprecated]
pub type RTDMessageExpiredPhotoBuilder = MessageExpiredPhotoBuilder;

impl MessageExpiredPhotoBuilder {
    pub fn build(&self) -> MessageExpiredPhoto {
        self.inner.clone()
    }
}

impl AsRef<MessageExpiredPhoto> for MessageExpiredPhoto {
    fn as_ref(&self) -> &MessageExpiredPhoto {
        self
    }
}

impl AsRef<MessageExpiredPhoto> for MessageExpiredPhotoBuilder {
    fn as_ref(&self) -> &MessageExpiredPhoto {
        &self.inner
    }
}

/// An expired video message (self-destructed after TTL has elapsed)
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageExpiredVideo {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
}

impl RObject for MessageExpiredVideo {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageExpiredVideo {}

impl MessageExpiredVideo {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageExpiredVideoBuilder {
        let mut inner = MessageExpiredVideo::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageExpiredVideoBuilder { inner }
    }
}

#[doc(hidden)]
pub struct MessageExpiredVideoBuilder {
    inner: MessageExpiredVideo,
}

#[deprecated]
pub type RTDMessageExpiredVideoBuilder = MessageExpiredVideoBuilder;

impl MessageExpiredVideoBuilder {
    pub fn build(&self) -> MessageExpiredVideo {
        self.inner.clone()
    }
}

impl AsRef<MessageExpiredVideo> for MessageExpiredVideo {
    fn as_ref(&self) -> &MessageExpiredVideo {
        self
    }
}

impl AsRef<MessageExpiredVideo> for MessageExpiredVideoBuilder {
    fn as_ref(&self) -> &MessageExpiredVideo {
        &self.inner
    }
}

/// A message with a game
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageGame {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The game description
    game: Game,
}

impl RObject for MessageGame {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageGame {}

impl MessageGame {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageGameBuilder {
        let mut inner = MessageGame::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageGameBuilder { inner }
    }

    pub fn game(&self) -> &Game {
        &self.game
    }
}

#[doc(hidden)]
pub struct MessageGameBuilder {
    inner: MessageGame,
}

#[deprecated]
pub type RTDMessageGameBuilder = MessageGameBuilder;

impl MessageGameBuilder {
    pub fn build(&self) -> MessageGame {
        self.inner.clone()
    }

    pub fn game<T: AsRef<Game>>(&mut self, game: T) -> &mut Self {
        self.inner.game = game.as_ref().clone();
        self
    }
}

impl AsRef<MessageGame> for MessageGame {
    fn as_ref(&self) -> &MessageGame {
        self
    }
}

impl AsRef<MessageGame> for MessageGameBuilder {
    fn as_ref(&self) -> &MessageGame {
        &self.inner
    }
}

/// A new high score was achieved in a game
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageGameScore {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Identifier of the message with the game, can be an identifier of a deleted message

    #[serde(default)]
    game_message_id: i64,
    /// Identifier of the game; may be different from the games presented in the message with the game

    #[serde(
        deserialize_with = "super::_common::number_from_string",
        serialize_with = "super::_common::string_to_number"
    )]
    #[serde(default)]
    game_id: i64,
    /// New score

    #[serde(default)]
    score: i32,
}

impl RObject for MessageGameScore {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageGameScore {}

impl MessageGameScore {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageGameScoreBuilder {
        let mut inner = MessageGameScore::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageGameScoreBuilder { inner }
    }

    pub fn game_message_id(&self) -> i64 {
        self.game_message_id
    }

    pub fn game_id(&self) -> i64 {
        self.game_id
    }

    pub fn score(&self) -> i32 {
        self.score
    }
}

#[doc(hidden)]
pub struct MessageGameScoreBuilder {
    inner: MessageGameScore,
}

#[deprecated]
pub type RTDMessageGameScoreBuilder = MessageGameScoreBuilder;

impl MessageGameScoreBuilder {
    pub fn build(&self) -> MessageGameScore {
        self.inner.clone()
    }

    pub fn game_message_id(&mut self, game_message_id: i64) -> &mut Self {
        self.inner.game_message_id = game_message_id;
        self
    }

    pub fn game_id(&mut self, game_id: i64) -> &mut Self {
        self.inner.game_id = game_id;
        self
    }

    pub fn score(&mut self, score: i32) -> &mut Self {
        self.inner.score = score;
        self
    }
}

impl AsRef<MessageGameScore> for MessageGameScore {
    fn as_ref(&self) -> &MessageGameScore {
        self
    }
}

impl AsRef<MessageGameScore> for MessageGameScoreBuilder {
    fn as_ref(&self) -> &MessageGameScore {
        &self.inner
    }
}

/// A message with information about an invite to a video chat
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageInviteVideoChatParticipants {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Identifier of the video chat. The video chat can be received through the method getGroupCall

    #[serde(default)]
    group_call_id: i32,
    /// Invited user identifiers

    #[serde(default)]
    user_ids: Vec<i64>,
}

impl RObject for MessageInviteVideoChatParticipants {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageInviteVideoChatParticipants {}

impl MessageInviteVideoChatParticipants {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageInviteVideoChatParticipantsBuilder {
        let mut inner = MessageInviteVideoChatParticipants::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageInviteVideoChatParticipantsBuilder { inner }
    }

    pub fn group_call_id(&self) -> i32 {
        self.group_call_id
    }

    pub fn user_ids(&self) -> &Vec<i64> {
        &self.user_ids
    }
}

#[doc(hidden)]
pub struct MessageInviteVideoChatParticipantsBuilder {
    inner: MessageInviteVideoChatParticipants,
}

#[deprecated]
pub type RTDMessageInviteVideoChatParticipantsBuilder = MessageInviteVideoChatParticipantsBuilder;

impl MessageInviteVideoChatParticipantsBuilder {
    pub fn build(&self) -> MessageInviteVideoChatParticipants {
        self.inner.clone()
    }

    pub fn group_call_id(&mut self, group_call_id: i32) -> &mut Self {
        self.inner.group_call_id = group_call_id;
        self
    }

    pub fn user_ids(&mut self, user_ids: Vec<i64>) -> &mut Self {
        self.inner.user_ids = user_ids;
        self
    }
}

impl AsRef<MessageInviteVideoChatParticipants> for MessageInviteVideoChatParticipants {
    fn as_ref(&self) -> &MessageInviteVideoChatParticipants {
        self
    }
}

impl AsRef<MessageInviteVideoChatParticipants> for MessageInviteVideoChatParticipantsBuilder {
    fn as_ref(&self) -> &MessageInviteVideoChatParticipants {
        &self.inner
    }
}

/// A message with an invoice from a bot
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageInvoice {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Product title

    #[serde(default)]
    title: String,
    /// A message with an invoice from a bot

    #[serde(default)]
    description: String,
    /// Product photo; may be null
    photo: Option<Photo>,
    /// Currency for the product price

    #[serde(default)]
    currency: String,
    /// Product total price in the smallest units of the currency

    #[serde(default)]
    total_amount: i64,
    /// Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter}

    #[serde(default)]
    start_parameter: String,
    /// True, if the invoice is a test invoice

    #[serde(default)]
    is_test: bool,
    /// True, if the shipping address must be specified

    #[serde(default)]
    need_shipping_address: bool,
    /// The identifier of the message with the receipt, after the product has been purchased

    #[serde(default)]
    receipt_message_id: i64,
}

impl RObject for MessageInvoice {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageInvoice {}

impl MessageInvoice {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageInvoiceBuilder {
        let mut inner = MessageInvoice::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageInvoiceBuilder { inner }
    }

    pub fn title(&self) -> &String {
        &self.title
    }

    pub fn description(&self) -> &String {
        &self.description
    }

    pub fn photo(&self) -> &Option<Photo> {
        &self.photo
    }

    pub fn currency(&self) -> &String {
        &self.currency
    }

    pub fn total_amount(&self) -> i64 {
        self.total_amount
    }

    pub fn start_parameter(&self) -> &String {
        &self.start_parameter
    }

    pub fn is_test(&self) -> bool {
        self.is_test
    }

    pub fn need_shipping_address(&self) -> bool {
        self.need_shipping_address
    }

    pub fn receipt_message_id(&self) -> i64 {
        self.receipt_message_id
    }
}

#[doc(hidden)]
pub struct MessageInvoiceBuilder {
    inner: MessageInvoice,
}

#[deprecated]
pub type RTDMessageInvoiceBuilder = MessageInvoiceBuilder;

impl MessageInvoiceBuilder {
    pub fn build(&self) -> MessageInvoice {
        self.inner.clone()
    }

    pub fn title<T: AsRef<str>>(&mut self, title: T) -> &mut Self {
        self.inner.title = title.as_ref().to_string();
        self
    }

    pub fn description<T: AsRef<str>>(&mut self, description: T) -> &mut Self {
        self.inner.description = description.as_ref().to_string();
        self
    }

    pub fn photo<T: AsRef<Photo>>(&mut self, photo: T) -> &mut Self {
        self.inner.photo = Some(photo.as_ref().clone());
        self
    }

    pub fn currency<T: AsRef<str>>(&mut self, currency: T) -> &mut Self {
        self.inner.currency = currency.as_ref().to_string();
        self
    }

    pub fn total_amount(&mut self, total_amount: i64) -> &mut Self {
        self.inner.total_amount = total_amount;
        self
    }

    pub fn start_parameter<T: AsRef<str>>(&mut self, start_parameter: T) -> &mut Self {
        self.inner.start_parameter = start_parameter.as_ref().to_string();
        self
    }

    pub fn is_test(&mut self, is_test: bool) -> &mut Self {
        self.inner.is_test = is_test;
        self
    }

    pub fn need_shipping_address(&mut self, need_shipping_address: bool) -> &mut Self {
        self.inner.need_shipping_address = need_shipping_address;
        self
    }

    pub fn receipt_message_id(&mut self, receipt_message_id: i64) -> &mut Self {
        self.inner.receipt_message_id = receipt_message_id;
        self
    }
}

impl AsRef<MessageInvoice> for MessageInvoice {
    fn as_ref(&self) -> &MessageInvoice {
        self
    }
}

impl AsRef<MessageInvoice> for MessageInvoiceBuilder {
    fn as_ref(&self) -> &MessageInvoice {
        &self.inner
    }
}

/// A message with a location
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageLocation {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The location description
    location: Location,
    /// Time relative to the message send date, for which the location can be updated, in seconds

    #[serde(default)]
    live_period: i32,
    /// Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes

    #[serde(default)]
    expires_in: i32,
    /// For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown

    #[serde(default)]
    heading: i32,
    /// For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only for the message sender

    #[serde(default)]
    proximity_alert_radius: i32,
}

impl RObject for MessageLocation {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageLocation {}

impl MessageLocation {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageLocationBuilder {
        let mut inner = MessageLocation::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageLocationBuilder { inner }
    }

    pub fn location(&self) -> &Location {
        &self.location
    }

    pub fn live_period(&self) -> i32 {
        self.live_period
    }

    pub fn expires_in(&self) -> i32 {
        self.expires_in
    }

    pub fn heading(&self) -> i32 {
        self.heading
    }

    pub fn proximity_alert_radius(&self) -> i32 {
        self.proximity_alert_radius
    }
}

#[doc(hidden)]
pub struct MessageLocationBuilder {
    inner: MessageLocation,
}

#[deprecated]
pub type RTDMessageLocationBuilder = MessageLocationBuilder;

impl MessageLocationBuilder {
    pub fn build(&self) -> MessageLocation {
        self.inner.clone()
    }

    pub fn location<T: AsRef<Location>>(&mut self, location: T) -> &mut Self {
        self.inner.location = location.as_ref().clone();
        self
    }

    pub fn live_period(&mut self, live_period: i32) -> &mut Self {
        self.inner.live_period = live_period;
        self
    }

    pub fn expires_in(&mut self, expires_in: i32) -> &mut Self {
        self.inner.expires_in = expires_in;
        self
    }

    pub fn heading(&mut self, heading: i32) -> &mut Self {
        self.inner.heading = heading;
        self
    }

    pub fn proximity_alert_radius(&mut self, proximity_alert_radius: i32) -> &mut Self {
        self.inner.proximity_alert_radius = proximity_alert_radius;
        self
    }
}

impl AsRef<MessageLocation> for MessageLocation {
    fn as_ref(&self) -> &MessageLocation {
        self
    }
}

impl AsRef<MessageLocation> for MessageLocationBuilder {
    fn as_ref(&self) -> &MessageLocation {
        &self.inner
    }
}

/// Telegram Passport data has been received; for bots only
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessagePassportDataReceived {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// List of received Telegram Passport elements

    #[serde(default)]
    elements: Vec<EncryptedPassportElement>,
    /// Encrypted data credentials
    credentials: EncryptedCredentials,
}

impl RObject for MessagePassportDataReceived {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessagePassportDataReceived {}

impl MessagePassportDataReceived {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessagePassportDataReceivedBuilder {
        let mut inner = MessagePassportDataReceived::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessagePassportDataReceivedBuilder { inner }
    }

    pub fn elements(&self) -> &Vec<EncryptedPassportElement> {
        &self.elements
    }

    pub fn credentials(&self) -> &EncryptedCredentials {
        &self.credentials
    }
}

#[doc(hidden)]
pub struct MessagePassportDataReceivedBuilder {
    inner: MessagePassportDataReceived,
}

#[deprecated]
pub type RTDMessagePassportDataReceivedBuilder = MessagePassportDataReceivedBuilder;

impl MessagePassportDataReceivedBuilder {
    pub fn build(&self) -> MessagePassportDataReceived {
        self.inner.clone()
    }

    pub fn elements(&mut self, elements: Vec<EncryptedPassportElement>) -> &mut Self {
        self.inner.elements = elements;
        self
    }

    pub fn credentials<T: AsRef<EncryptedCredentials>>(&mut self, credentials: T) -> &mut Self {
        self.inner.credentials = credentials.as_ref().clone();
        self
    }
}

impl AsRef<MessagePassportDataReceived> for MessagePassportDataReceived {
    fn as_ref(&self) -> &MessagePassportDataReceived {
        self
    }
}

impl AsRef<MessagePassportDataReceived> for MessagePassportDataReceivedBuilder {
    fn as_ref(&self) -> &MessagePassportDataReceived {
        &self.inner
    }
}

/// Telegram Passport data has been sent
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessagePassportDataSent {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// List of Telegram Passport element types sent

    #[serde(default)]
    types: Vec<PassportElementType>,
}

impl RObject for MessagePassportDataSent {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessagePassportDataSent {}

impl MessagePassportDataSent {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessagePassportDataSentBuilder {
        let mut inner = MessagePassportDataSent::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessagePassportDataSentBuilder { inner }
    }

    pub fn types(&self) -> &Vec<PassportElementType> {
        &self.types
    }
}

#[doc(hidden)]
pub struct MessagePassportDataSentBuilder {
    inner: MessagePassportDataSent,
}

#[deprecated]
pub type RTDMessagePassportDataSentBuilder = MessagePassportDataSentBuilder;

impl MessagePassportDataSentBuilder {
    pub fn build(&self) -> MessagePassportDataSent {
        self.inner.clone()
    }

    pub fn types(&mut self, types: Vec<PassportElementType>) -> &mut Self {
        self.inner.types = types;
        self
    }
}

impl AsRef<MessagePassportDataSent> for MessagePassportDataSent {
    fn as_ref(&self) -> &MessagePassportDataSent {
        self
    }
}

impl AsRef<MessagePassportDataSent> for MessagePassportDataSentBuilder {
    fn as_ref(&self) -> &MessagePassportDataSent {
        &self.inner
    }
}

/// A payment has been completed
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessagePaymentSuccessful {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Identifier of the chat, containing the corresponding invoice message; 0 if unknown

    #[serde(default)]
    invoice_chat_id: i64,
    /// Identifier of the message with the corresponding invoice; can be an identifier of a deleted message

    #[serde(default)]
    invoice_message_id: i64,
    /// Currency for the price of the product

    #[serde(default)]
    currency: String,
    /// Total price for the product, in the smallest units of the currency

    #[serde(default)]
    total_amount: i64,
}

impl RObject for MessagePaymentSuccessful {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessagePaymentSuccessful {}

impl MessagePaymentSuccessful {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessagePaymentSuccessfulBuilder {
        let mut inner = MessagePaymentSuccessful::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessagePaymentSuccessfulBuilder { inner }
    }

    pub fn invoice_chat_id(&self) -> i64 {
        self.invoice_chat_id
    }

    pub fn invoice_message_id(&self) -> i64 {
        self.invoice_message_id
    }

    pub fn currency(&self) -> &String {
        &self.currency
    }

    pub fn total_amount(&self) -> i64 {
        self.total_amount
    }
}

#[doc(hidden)]
pub struct MessagePaymentSuccessfulBuilder {
    inner: MessagePaymentSuccessful,
}

#[deprecated]
pub type RTDMessagePaymentSuccessfulBuilder = MessagePaymentSuccessfulBuilder;

impl MessagePaymentSuccessfulBuilder {
    pub fn build(&self) -> MessagePaymentSuccessful {
        self.inner.clone()
    }

    pub fn invoice_chat_id(&mut self, invoice_chat_id: i64) -> &mut Self {
        self.inner.invoice_chat_id = invoice_chat_id;
        self
    }

    pub fn invoice_message_id(&mut self, invoice_message_id: i64) -> &mut Self {
        self.inner.invoice_message_id = invoice_message_id;
        self
    }

    pub fn currency<T: AsRef<str>>(&mut self, currency: T) -> &mut Self {
        self.inner.currency = currency.as_ref().to_string();
        self
    }

    pub fn total_amount(&mut self, total_amount: i64) -> &mut Self {
        self.inner.total_amount = total_amount;
        self
    }
}

impl AsRef<MessagePaymentSuccessful> for MessagePaymentSuccessful {
    fn as_ref(&self) -> &MessagePaymentSuccessful {
        self
    }
}

impl AsRef<MessagePaymentSuccessful> for MessagePaymentSuccessfulBuilder {
    fn as_ref(&self) -> &MessagePaymentSuccessful {
        &self.inner
    }
}

/// A payment has been completed; for bots only
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessagePaymentSuccessfulBot {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Currency for price of the product

    #[serde(default)]
    currency: String,
    /// Total price for the product, in the smallest units of the currency

    #[serde(default)]
    total_amount: i64,
    /// Invoice payload

    #[serde(default)]
    invoice_payload: String,
    /// Identifier of the shipping option chosen by the user; may be empty if not applicable

    #[serde(default)]
    shipping_option_id: String,
    /// Information about the order; may be null
    order_info: Option<OrderInfo>,
    /// Telegram payment identifier

    #[serde(default)]
    telegram_payment_charge_id: String,
    /// Provider payment identifier

    #[serde(default)]
    provider_payment_charge_id: String,
}

impl RObject for MessagePaymentSuccessfulBot {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessagePaymentSuccessfulBot {}

impl MessagePaymentSuccessfulBot {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessagePaymentSuccessfulBotBuilder {
        let mut inner = MessagePaymentSuccessfulBot::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessagePaymentSuccessfulBotBuilder { inner }
    }

    pub fn currency(&self) -> &String {
        &self.currency
    }

    pub fn total_amount(&self) -> i64 {
        self.total_amount
    }

    pub fn invoice_payload(&self) -> &String {
        &self.invoice_payload
    }

    pub fn shipping_option_id(&self) -> &String {
        &self.shipping_option_id
    }

    pub fn order_info(&self) -> &Option<OrderInfo> {
        &self.order_info
    }

    pub fn telegram_payment_charge_id(&self) -> &String {
        &self.telegram_payment_charge_id
    }

    pub fn provider_payment_charge_id(&self) -> &String {
        &self.provider_payment_charge_id
    }
}

#[doc(hidden)]
pub struct MessagePaymentSuccessfulBotBuilder {
    inner: MessagePaymentSuccessfulBot,
}

#[deprecated]
pub type RTDMessagePaymentSuccessfulBotBuilder = MessagePaymentSuccessfulBotBuilder;

impl MessagePaymentSuccessfulBotBuilder {
    pub fn build(&self) -> MessagePaymentSuccessfulBot {
        self.inner.clone()
    }

    pub fn currency<T: AsRef<str>>(&mut self, currency: T) -> &mut Self {
        self.inner.currency = currency.as_ref().to_string();
        self
    }

    pub fn total_amount(&mut self, total_amount: i64) -> &mut Self {
        self.inner.total_amount = total_amount;
        self
    }

    pub fn invoice_payload<T: AsRef<str>>(&mut self, invoice_payload: T) -> &mut Self {
        self.inner.invoice_payload = invoice_payload.as_ref().to_string();
        self
    }

    pub fn shipping_option_id<T: AsRef<str>>(&mut self, shipping_option_id: T) -> &mut Self {
        self.inner.shipping_option_id = shipping_option_id.as_ref().to_string();
        self
    }

    pub fn order_info<T: AsRef<OrderInfo>>(&mut self, order_info: T) -> &mut Self {
        self.inner.order_info = Some(order_info.as_ref().clone());
        self
    }

    pub fn telegram_payment_charge_id<T: AsRef<str>>(
        &mut self,
        telegram_payment_charge_id: T,
    ) -> &mut Self {
        self.inner.telegram_payment_charge_id = telegram_payment_charge_id.as_ref().to_string();
        self
    }

    pub fn provider_payment_charge_id<T: AsRef<str>>(
        &mut self,
        provider_payment_charge_id: T,
    ) -> &mut Self {
        self.inner.provider_payment_charge_id = provider_payment_charge_id.as_ref().to_string();
        self
    }
}

impl AsRef<MessagePaymentSuccessfulBot> for MessagePaymentSuccessfulBot {
    fn as_ref(&self) -> &MessagePaymentSuccessfulBot {
        self
    }
}

impl AsRef<MessagePaymentSuccessfulBot> for MessagePaymentSuccessfulBotBuilder {
    fn as_ref(&self) -> &MessagePaymentSuccessfulBot {
        &self.inner
    }
}

/// A photo message
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessagePhoto {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The photo description
    photo: Photo,
    /// Photo caption
    caption: FormattedText,
    /// True, if the photo must be blurred and must be shown only while tapped

    #[serde(default)]
    is_secret: bool,
}

impl RObject for MessagePhoto {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessagePhoto {}

impl MessagePhoto {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessagePhotoBuilder {
        let mut inner = MessagePhoto::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessagePhotoBuilder { inner }
    }

    pub fn photo(&self) -> &Photo {
        &self.photo
    }

    pub fn caption(&self) -> &FormattedText {
        &self.caption
    }

    pub fn is_secret(&self) -> bool {
        self.is_secret
    }
}

#[doc(hidden)]
pub struct MessagePhotoBuilder {
    inner: MessagePhoto,
}

#[deprecated]
pub type RTDMessagePhotoBuilder = MessagePhotoBuilder;

impl MessagePhotoBuilder {
    pub fn build(&self) -> MessagePhoto {
        self.inner.clone()
    }

    pub fn photo<T: AsRef<Photo>>(&mut self, photo: T) -> &mut Self {
        self.inner.photo = photo.as_ref().clone();
        self
    }

    pub fn caption<T: AsRef<FormattedText>>(&mut self, caption: T) -> &mut Self {
        self.inner.caption = caption.as_ref().clone();
        self
    }

    pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
        self.inner.is_secret = is_secret;
        self
    }
}

impl AsRef<MessagePhoto> for MessagePhoto {
    fn as_ref(&self) -> &MessagePhoto {
        self
    }
}

impl AsRef<MessagePhoto> for MessagePhotoBuilder {
    fn as_ref(&self) -> &MessagePhoto {
        &self.inner
    }
}

/// A message has been pinned
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessagePinMessage {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Identifier of the pinned message, can be an identifier of a deleted message or 0

    #[serde(default)]
    message_id: i64,
}

impl RObject for MessagePinMessage {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessagePinMessage {}

impl MessagePinMessage {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessagePinMessageBuilder {
        let mut inner = MessagePinMessage::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessagePinMessageBuilder { inner }
    }

    pub fn message_id(&self) -> i64 {
        self.message_id
    }
}

#[doc(hidden)]
pub struct MessagePinMessageBuilder {
    inner: MessagePinMessage,
}

#[deprecated]
pub type RTDMessagePinMessageBuilder = MessagePinMessageBuilder;

impl MessagePinMessageBuilder {
    pub fn build(&self) -> MessagePinMessage {
        self.inner.clone()
    }

    pub fn message_id(&mut self, message_id: i64) -> &mut Self {
        self.inner.message_id = message_id;
        self
    }
}

impl AsRef<MessagePinMessage> for MessagePinMessage {
    fn as_ref(&self) -> &MessagePinMessage {
        self
    }
}

impl AsRef<MessagePinMessage> for MessagePinMessageBuilder {
    fn as_ref(&self) -> &MessagePinMessage {
        &self.inner
    }
}

/// A message with a poll
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessagePoll {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The poll description
    poll: Poll,
}

impl RObject for MessagePoll {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessagePoll {}

impl MessagePoll {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessagePollBuilder {
        let mut inner = MessagePoll::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessagePollBuilder { inner }
    }

    pub fn poll(&self) -> &Poll {
        &self.poll
    }
}

#[doc(hidden)]
pub struct MessagePollBuilder {
    inner: MessagePoll,
}

#[deprecated]
pub type RTDMessagePollBuilder = MessagePollBuilder;

impl MessagePollBuilder {
    pub fn build(&self) -> MessagePoll {
        self.inner.clone()
    }

    pub fn poll<T: AsRef<Poll>>(&mut self, poll: T) -> &mut Self {
        self.inner.poll = poll.as_ref().clone();
        self
    }
}

impl AsRef<MessagePoll> for MessagePoll {
    fn as_ref(&self) -> &MessagePoll {
        self
    }
}

impl AsRef<MessagePoll> for MessagePollBuilder {
    fn as_ref(&self) -> &MessagePoll {
        &self.inner
    }
}

/// A user in the chat came within proximity alert range
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageProximityAlertTriggered {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The identifier of a user or chat that triggered the proximity alert

    #[serde(skip_serializing_if = "MessageSender::_is_default")]
    traveler_id: MessageSender,
    /// The identifier of a user or chat that subscribed for the proximity alert

    #[serde(skip_serializing_if = "MessageSender::_is_default")]
    watcher_id: MessageSender,
    /// The distance between the users

    #[serde(default)]
    distance: i32,
}

impl RObject for MessageProximityAlertTriggered {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageProximityAlertTriggered {}

impl MessageProximityAlertTriggered {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageProximityAlertTriggeredBuilder {
        let mut inner = MessageProximityAlertTriggered::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageProximityAlertTriggeredBuilder { inner }
    }

    pub fn traveler_id(&self) -> &MessageSender {
        &self.traveler_id
    }

    pub fn watcher_id(&self) -> &MessageSender {
        &self.watcher_id
    }

    pub fn distance(&self) -> i32 {
        self.distance
    }
}

#[doc(hidden)]
pub struct MessageProximityAlertTriggeredBuilder {
    inner: MessageProximityAlertTriggered,
}

#[deprecated]
pub type RTDMessageProximityAlertTriggeredBuilder = MessageProximityAlertTriggeredBuilder;

impl MessageProximityAlertTriggeredBuilder {
    pub fn build(&self) -> MessageProximityAlertTriggered {
        self.inner.clone()
    }

    pub fn traveler_id<T: AsRef<MessageSender>>(&mut self, traveler_id: T) -> &mut Self {
        self.inner.traveler_id = traveler_id.as_ref().clone();
        self
    }

    pub fn watcher_id<T: AsRef<MessageSender>>(&mut self, watcher_id: T) -> &mut Self {
        self.inner.watcher_id = watcher_id.as_ref().clone();
        self
    }

    pub fn distance(&mut self, distance: i32) -> &mut Self {
        self.inner.distance = distance;
        self
    }
}

impl AsRef<MessageProximityAlertTriggered> for MessageProximityAlertTriggered {
    fn as_ref(&self) -> &MessageProximityAlertTriggered {
        self
    }
}

impl AsRef<MessageProximityAlertTriggered> for MessageProximityAlertTriggeredBuilder {
    fn as_ref(&self) -> &MessageProximityAlertTriggered {
        &self.inner
    }
}

/// A screenshot of a message in the chat has been taken
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageScreenshotTaken {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
}

impl RObject for MessageScreenshotTaken {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageScreenshotTaken {}

impl MessageScreenshotTaken {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageScreenshotTakenBuilder {
        let mut inner = MessageScreenshotTaken::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageScreenshotTakenBuilder { inner }
    }
}

#[doc(hidden)]
pub struct MessageScreenshotTakenBuilder {
    inner: MessageScreenshotTaken,
}

#[deprecated]
pub type RTDMessageScreenshotTakenBuilder = MessageScreenshotTakenBuilder;

impl MessageScreenshotTakenBuilder {
    pub fn build(&self) -> MessageScreenshotTaken {
        self.inner.clone()
    }
}

impl AsRef<MessageScreenshotTaken> for MessageScreenshotTaken {
    fn as_ref(&self) -> &MessageScreenshotTaken {
        self
    }
}

impl AsRef<MessageScreenshotTaken> for MessageScreenshotTakenBuilder {
    fn as_ref(&self) -> &MessageScreenshotTaken {
        &self.inner
    }
}

/// A sticker message
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageSticker {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The sticker description
    sticker: Sticker,
}

impl RObject for MessageSticker {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageSticker {}

impl MessageSticker {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageStickerBuilder {
        let mut inner = MessageSticker::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageStickerBuilder { inner }
    }

    pub fn sticker(&self) -> &Sticker {
        &self.sticker
    }
}

#[doc(hidden)]
pub struct MessageStickerBuilder {
    inner: MessageSticker,
}

#[deprecated]
pub type RTDMessageStickerBuilder = MessageStickerBuilder;

impl MessageStickerBuilder {
    pub fn build(&self) -> MessageSticker {
        self.inner.clone()
    }

    pub fn sticker<T: AsRef<Sticker>>(&mut self, sticker: T) -> &mut Self {
        self.inner.sticker = sticker.as_ref().clone();
        self
    }
}

impl AsRef<MessageSticker> for MessageSticker {
    fn as_ref(&self) -> &MessageSticker {
        self
    }
}

impl AsRef<MessageSticker> for MessageStickerBuilder {
    fn as_ref(&self) -> &MessageSticker {
        &self.inner
    }
}

/// A newly created supergroup or channel
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageSupergroupChatCreate {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Title of the supergroup or channel

    #[serde(default)]
    title: String,
}

impl RObject for MessageSupergroupChatCreate {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageSupergroupChatCreate {}

impl MessageSupergroupChatCreate {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageSupergroupChatCreateBuilder {
        let mut inner = MessageSupergroupChatCreate::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageSupergroupChatCreateBuilder { inner }
    }

    pub fn title(&self) -> &String {
        &self.title
    }
}

#[doc(hidden)]
pub struct MessageSupergroupChatCreateBuilder {
    inner: MessageSupergroupChatCreate,
}

#[deprecated]
pub type RTDMessageSupergroupChatCreateBuilder = MessageSupergroupChatCreateBuilder;

impl MessageSupergroupChatCreateBuilder {
    pub fn build(&self) -> MessageSupergroupChatCreate {
        self.inner.clone()
    }

    pub fn title<T: AsRef<str>>(&mut self, title: T) -> &mut Self {
        self.inner.title = title.as_ref().to_string();
        self
    }
}

impl AsRef<MessageSupergroupChatCreate> for MessageSupergroupChatCreate {
    fn as_ref(&self) -> &MessageSupergroupChatCreate {
        self
    }
}

impl AsRef<MessageSupergroupChatCreate> for MessageSupergroupChatCreateBuilder {
    fn as_ref(&self) -> &MessageSupergroupChatCreate {
        &self.inner
    }
}

/// A text message
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageText {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Text of the message
    text: FormattedText,
    /// A preview of the web page that's mentioned in the text; may be null
    web_page: Option<WebPage>,
}

impl RObject for MessageText {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageText {}

impl MessageText {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageTextBuilder {
        let mut inner = MessageText::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageTextBuilder { inner }
    }

    pub fn text(&self) -> &FormattedText {
        &self.text
    }

    pub fn web_page(&self) -> &Option<WebPage> {
        &self.web_page
    }
}

#[doc(hidden)]
pub struct MessageTextBuilder {
    inner: MessageText,
}

#[deprecated]
pub type RTDMessageTextBuilder = MessageTextBuilder;

impl MessageTextBuilder {
    pub fn build(&self) -> MessageText {
        self.inner.clone()
    }

    pub fn text<T: AsRef<FormattedText>>(&mut self, text: T) -> &mut Self {
        self.inner.text = text.as_ref().clone();
        self
    }

    pub fn web_page<T: AsRef<WebPage>>(&mut self, web_page: T) -> &mut Self {
        self.inner.web_page = Some(web_page.as_ref().clone());
        self
    }
}

impl AsRef<MessageText> for MessageText {
    fn as_ref(&self) -> &MessageText {
        self
    }
}

impl AsRef<MessageText> for MessageTextBuilder {
    fn as_ref(&self) -> &MessageText {
        &self.inner
    }
}

/// Message content that is not supported in the current TDLib version
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageUnsupported {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
}

impl RObject for MessageUnsupported {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageUnsupported {}

impl MessageUnsupported {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageUnsupportedBuilder {
        let mut inner = MessageUnsupported::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageUnsupportedBuilder { inner }
    }
}

#[doc(hidden)]
pub struct MessageUnsupportedBuilder {
    inner: MessageUnsupported,
}

#[deprecated]
pub type RTDMessageUnsupportedBuilder = MessageUnsupportedBuilder;

impl MessageUnsupportedBuilder {
    pub fn build(&self) -> MessageUnsupported {
        self.inner.clone()
    }
}

impl AsRef<MessageUnsupported> for MessageUnsupported {
    fn as_ref(&self) -> &MessageUnsupported {
        self
    }
}

impl AsRef<MessageUnsupported> for MessageUnsupportedBuilder {
    fn as_ref(&self) -> &MessageUnsupported {
        &self.inner
    }
}

/// A message with information about a venue
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageVenue {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The venue description
    venue: Venue,
}

impl RObject for MessageVenue {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageVenue {}

impl MessageVenue {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageVenueBuilder {
        let mut inner = MessageVenue::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageVenueBuilder { inner }
    }

    pub fn venue(&self) -> &Venue {
        &self.venue
    }
}

#[doc(hidden)]
pub struct MessageVenueBuilder {
    inner: MessageVenue,
}

#[deprecated]
pub type RTDMessageVenueBuilder = MessageVenueBuilder;

impl MessageVenueBuilder {
    pub fn build(&self) -> MessageVenue {
        self.inner.clone()
    }

    pub fn venue<T: AsRef<Venue>>(&mut self, venue: T) -> &mut Self {
        self.inner.venue = venue.as_ref().clone();
        self
    }
}

impl AsRef<MessageVenue> for MessageVenue {
    fn as_ref(&self) -> &MessageVenue {
        self
    }
}

impl AsRef<MessageVenue> for MessageVenueBuilder {
    fn as_ref(&self) -> &MessageVenue {
        &self.inner
    }
}

/// A video message
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageVideo {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The video description
    video: Video,
    /// Video caption
    caption: FormattedText,
    /// True, if the video thumbnail must be blurred and the video must be shown only while tapped

    #[serde(default)]
    is_secret: bool,
}

impl RObject for MessageVideo {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageVideo {}

impl MessageVideo {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageVideoBuilder {
        let mut inner = MessageVideo::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageVideoBuilder { inner }
    }

    pub fn video(&self) -> &Video {
        &self.video
    }

    pub fn caption(&self) -> &FormattedText {
        &self.caption
    }

    pub fn is_secret(&self) -> bool {
        self.is_secret
    }
}

#[doc(hidden)]
pub struct MessageVideoBuilder {
    inner: MessageVideo,
}

#[deprecated]
pub type RTDMessageVideoBuilder = MessageVideoBuilder;

impl MessageVideoBuilder {
    pub fn build(&self) -> MessageVideo {
        self.inner.clone()
    }

    pub fn video<T: AsRef<Video>>(&mut self, video: T) -> &mut Self {
        self.inner.video = video.as_ref().clone();
        self
    }

    pub fn caption<T: AsRef<FormattedText>>(&mut self, caption: T) -> &mut Self {
        self.inner.caption = caption.as_ref().clone();
        self
    }

    pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
        self.inner.is_secret = is_secret;
        self
    }
}

impl AsRef<MessageVideo> for MessageVideo {
    fn as_ref(&self) -> &MessageVideo {
        self
    }
}

impl AsRef<MessageVideo> for MessageVideoBuilder {
    fn as_ref(&self) -> &MessageVideo {
        &self.inner
    }
}

/// A message with information about an ended video chat
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageVideoChatEnded {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Call duration, in seconds

    #[serde(default)]
    duration: i32,
}

impl RObject for MessageVideoChatEnded {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageVideoChatEnded {}

impl MessageVideoChatEnded {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageVideoChatEndedBuilder {
        let mut inner = MessageVideoChatEnded::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageVideoChatEndedBuilder { inner }
    }

    pub fn duration(&self) -> i32 {
        self.duration
    }
}

#[doc(hidden)]
pub struct MessageVideoChatEndedBuilder {
    inner: MessageVideoChatEnded,
}

#[deprecated]
pub type RTDMessageVideoChatEndedBuilder = MessageVideoChatEndedBuilder;

impl MessageVideoChatEndedBuilder {
    pub fn build(&self) -> MessageVideoChatEnded {
        self.inner.clone()
    }

    pub fn duration(&mut self, duration: i32) -> &mut Self {
        self.inner.duration = duration;
        self
    }
}

impl AsRef<MessageVideoChatEnded> for MessageVideoChatEnded {
    fn as_ref(&self) -> &MessageVideoChatEnded {
        self
    }
}

impl AsRef<MessageVideoChatEnded> for MessageVideoChatEndedBuilder {
    fn as_ref(&self) -> &MessageVideoChatEnded {
        &self.inner
    }
}

/// A new video chat was scheduled
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageVideoChatScheduled {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Identifier of the video chat. The video chat can be received through the method getGroupCall

    #[serde(default)]
    group_call_id: i32,
    /// Point in time (Unix timestamp) when the group call is supposed to be started by an administrator

    #[serde(default)]
    start_date: i32,
}

impl RObject for MessageVideoChatScheduled {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageVideoChatScheduled {}

impl MessageVideoChatScheduled {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageVideoChatScheduledBuilder {
        let mut inner = MessageVideoChatScheduled::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageVideoChatScheduledBuilder { inner }
    }

    pub fn group_call_id(&self) -> i32 {
        self.group_call_id
    }

    pub fn start_date(&self) -> i32 {
        self.start_date
    }
}

#[doc(hidden)]
pub struct MessageVideoChatScheduledBuilder {
    inner: MessageVideoChatScheduled,
}

#[deprecated]
pub type RTDMessageVideoChatScheduledBuilder = MessageVideoChatScheduledBuilder;

impl MessageVideoChatScheduledBuilder {
    pub fn build(&self) -> MessageVideoChatScheduled {
        self.inner.clone()
    }

    pub fn group_call_id(&mut self, group_call_id: i32) -> &mut Self {
        self.inner.group_call_id = group_call_id;
        self
    }

    pub fn start_date(&mut self, start_date: i32) -> &mut Self {
        self.inner.start_date = start_date;
        self
    }
}

impl AsRef<MessageVideoChatScheduled> for MessageVideoChatScheduled {
    fn as_ref(&self) -> &MessageVideoChatScheduled {
        self
    }
}

impl AsRef<MessageVideoChatScheduled> for MessageVideoChatScheduledBuilder {
    fn as_ref(&self) -> &MessageVideoChatScheduled {
        &self.inner
    }
}

/// A newly created video chat
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageVideoChatStarted {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Identifier of the video chat. The video chat can be received through the method getGroupCall

    #[serde(default)]
    group_call_id: i32,
}

impl RObject for MessageVideoChatStarted {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageVideoChatStarted {}

impl MessageVideoChatStarted {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageVideoChatStartedBuilder {
        let mut inner = MessageVideoChatStarted::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageVideoChatStartedBuilder { inner }
    }

    pub fn group_call_id(&self) -> i32 {
        self.group_call_id
    }
}

#[doc(hidden)]
pub struct MessageVideoChatStartedBuilder {
    inner: MessageVideoChatStarted,
}

#[deprecated]
pub type RTDMessageVideoChatStartedBuilder = MessageVideoChatStartedBuilder;

impl MessageVideoChatStartedBuilder {
    pub fn build(&self) -> MessageVideoChatStarted {
        self.inner.clone()
    }

    pub fn group_call_id(&mut self, group_call_id: i32) -> &mut Self {
        self.inner.group_call_id = group_call_id;
        self
    }
}

impl AsRef<MessageVideoChatStarted> for MessageVideoChatStarted {
    fn as_ref(&self) -> &MessageVideoChatStarted {
        self
    }
}

impl AsRef<MessageVideoChatStarted> for MessageVideoChatStartedBuilder {
    fn as_ref(&self) -> &MessageVideoChatStarted {
        &self.inner
    }
}

/// A video note message
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageVideoNote {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The video note description
    video_note: VideoNote,
    /// True, if at least one of the recipients has viewed the video note

    #[serde(default)]
    is_viewed: bool,
    /// True, if the video note thumbnail must be blurred and the video note must be shown only while tapped

    #[serde(default)]
    is_secret: bool,
}

impl RObject for MessageVideoNote {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageVideoNote {}

impl MessageVideoNote {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageVideoNoteBuilder {
        let mut inner = MessageVideoNote::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageVideoNoteBuilder { inner }
    }

    pub fn video_note(&self) -> &VideoNote {
        &self.video_note
    }

    pub fn is_viewed(&self) -> bool {
        self.is_viewed
    }

    pub fn is_secret(&self) -> bool {
        self.is_secret
    }
}

#[doc(hidden)]
pub struct MessageVideoNoteBuilder {
    inner: MessageVideoNote,
}

#[deprecated]
pub type RTDMessageVideoNoteBuilder = MessageVideoNoteBuilder;

impl MessageVideoNoteBuilder {
    pub fn build(&self) -> MessageVideoNote {
        self.inner.clone()
    }

    pub fn video_note<T: AsRef<VideoNote>>(&mut self, video_note: T) -> &mut Self {
        self.inner.video_note = video_note.as_ref().clone();
        self
    }

    pub fn is_viewed(&mut self, is_viewed: bool) -> &mut Self {
        self.inner.is_viewed = is_viewed;
        self
    }

    pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
        self.inner.is_secret = is_secret;
        self
    }
}

impl AsRef<MessageVideoNote> for MessageVideoNote {
    fn as_ref(&self) -> &MessageVideoNote {
        self
    }
}

impl AsRef<MessageVideoNote> for MessageVideoNoteBuilder {
    fn as_ref(&self) -> &MessageVideoNote {
        &self.inner
    }
}

/// A voice note message
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageVoiceNote {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// The voice note description
    voice_note: VoiceNote,
    /// Voice note caption
    caption: FormattedText,
    /// True, if at least one of the recipients has listened to the voice note

    #[serde(default)]
    is_listened: bool,
}

impl RObject for MessageVoiceNote {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageVoiceNote {}

impl MessageVoiceNote {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageVoiceNoteBuilder {
        let mut inner = MessageVoiceNote::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageVoiceNoteBuilder { inner }
    }

    pub fn voice_note(&self) -> &VoiceNote {
        &self.voice_note
    }

    pub fn caption(&self) -> &FormattedText {
        &self.caption
    }

    pub fn is_listened(&self) -> bool {
        self.is_listened
    }
}

#[doc(hidden)]
pub struct MessageVoiceNoteBuilder {
    inner: MessageVoiceNote,
}

#[deprecated]
pub type RTDMessageVoiceNoteBuilder = MessageVoiceNoteBuilder;

impl MessageVoiceNoteBuilder {
    pub fn build(&self) -> MessageVoiceNote {
        self.inner.clone()
    }

    pub fn voice_note<T: AsRef<VoiceNote>>(&mut self, voice_note: T) -> &mut Self {
        self.inner.voice_note = voice_note.as_ref().clone();
        self
    }

    pub fn caption<T: AsRef<FormattedText>>(&mut self, caption: T) -> &mut Self {
        self.inner.caption = caption.as_ref().clone();
        self
    }

    pub fn is_listened(&mut self, is_listened: bool) -> &mut Self {
        self.inner.is_listened = is_listened;
        self
    }
}

impl AsRef<MessageVoiceNote> for MessageVoiceNote {
    fn as_ref(&self) -> &MessageVoiceNote {
        self
    }
}

impl AsRef<MessageVoiceNote> for MessageVoiceNoteBuilder {
    fn as_ref(&self) -> &MessageVoiceNote {
        &self.inner
    }
}

/// The current user has connected a website by logging in using Telegram Login Widget on it
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct MessageWebsiteConnected {
    #[doc(hidden)]
    #[serde(rename(serialize = "@extra", deserialize = "@extra"))]
    extra: Option<String>,
    #[serde(rename(serialize = "@client_id", deserialize = "@client_id"))]
    client_id: Option<i32>,
    /// Domain name of the connected website

    #[serde(default)]
    domain_name: String,
}

impl RObject for MessageWebsiteConnected {
    #[doc(hidden)]
    fn extra(&self) -> Option<&str> {
        self.extra.as_deref()
    }
    #[doc(hidden)]
    fn client_id(&self) -> Option<i32> {
        self.client_id
    }
}

impl TDMessageContent for MessageWebsiteConnected {}

impl MessageWebsiteConnected {
    pub fn from_json<S: AsRef<str>>(json: S) -> Result<Self> {
        Ok(serde_json::from_str(json.as_ref())?)
    }
    pub fn builder() -> MessageWebsiteConnectedBuilder {
        let mut inner = MessageWebsiteConnected::default();
        inner.extra = Some(Uuid::new_v4().to_string());

        MessageWebsiteConnectedBuilder { inner }
    }

    pub fn domain_name(&self) -> &String {
        &self.domain_name
    }
}

#[doc(hidden)]
pub struct MessageWebsiteConnectedBuilder {
    inner: MessageWebsiteConnected,
}

#[deprecated]
pub type RTDMessageWebsiteConnectedBuilder = MessageWebsiteConnectedBuilder;

impl MessageWebsiteConnectedBuilder {
    pub fn build(&self) -> MessageWebsiteConnected {
        self.inner.clone()
    }

    pub fn domain_name<T: AsRef<str>>(&mut self, domain_name: T) -> &mut Self {
        self.inner.domain_name = domain_name.as_ref().to_string();
        self
    }
}

impl AsRef<MessageWebsiteConnected> for MessageWebsiteConnected {
    fn as_ref(&self) -> &MessageWebsiteConnected {
        self
    }
}

impl AsRef<MessageWebsiteConnected> for MessageWebsiteConnectedBuilder {
    fn as_ref(&self) -> &MessageWebsiteConnected {
        &self.inner
    }
}
